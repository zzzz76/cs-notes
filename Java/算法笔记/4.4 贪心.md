## 4.4 贪心

### 知识点

贪心是用来解决一类最优化问题，并希望由局部最优策略来推导全局最优结果的算法思想。贪心算法适用的问题一定满足最优子结构性质，即一个问题的最优解可以由它的子问题最优解有效的构造出来。



### PAT B1020

**题目描述：**

给定所有种类月饼的库存量、总售价、以及市场的最大需求量，求最大收益。

**输入格式：**

正整数N(<1000)表示月饼的种类数，正整数D(<500)表示市场的最大需求量。随后一行N个正数表示每种月饼的库存量，最后一行N个正数表示每种月饼的总售价。

**输出格式：**

输出最大收益，并精确到小数点后两位。

**代码：**

```java
import java.util.*;
import java.io.*;

public class B1020 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String[] l1 = br.readLine().split(" ");
        int n = Integer.parseInt(l1[0]);
        int d = Integer.parseInt(l1[1]);

        Cake[] cakes = new Cake[n];
        String[] l2 = br.readLine().split(" ");
        String[] l3 = br.readLine().split(" ");

        for (int i = 0; i < cakes.length; i++) {
            double store = Double.parseDouble(l2[i]);
            double sell = Double.parseDouble(l3[i]);
            double price = sell / store;
            cakes[i] = new Cake(store, sell, price);
        }

        Arrays.sort(cakes, new Comparator<Cake>() {
            @Override
            public int compare(Cake o1, Cake o2) {
                return o2.price < o1.price ? -1 : 1;
            }
        });

        double left = d;
        double total = 0;
        for (int i = 0; i < cakes.length; i++) {
            if (cakes[i].store <= left) {
                total += cakes[i].sell;
                left -= cakes[i].store;
            } else {
                total += cakes[i].price * left;
                left = 0;
            }
        }

        System.out.printf("%.2f\n", total);
    }
}

class Cake {
    double store; //库存量
    double sell; //总售价
    double price; //单价

    Cake(double store, double sell, double price) {
        this.store = store;
        this.sell = sell;
        this.price = price;
    }
}

```



