# 编辑字符串

*状态是子问题的解*

## 目录

1. 不同的子序列
2. 两个字符串的删除操作
3. 编辑距离



## 一、不同的子序列

[题目链接](https://leetcode.cn/problems/distinct-subsequences/)

**需求：**

给定一个字符串`s`和一个字符串`t`，计算在`s`的子序列中`t`出现的次数

```
输入：s = "rabbbit", t = "rabbit"
输出：3
解释：
如下图所示, 有 3 种可以从 s 中得到 "rabbit" 的方案。
rabb.b.it
ra.b.bbit
rab.b.bit
```



**思路：**

`dp[i][j]`表示在以s[j]结尾的字符串的子序列中，以t[i]结尾的字符串出现的次数

```java
class Solution {
    public int numDistinct(String s, String t) {
        int m = t.length();
        int n = s.length();

        //dp初始化
        int[][] dp = new int[m][n];
        int count = 0;
        for (int j = 0; j < n; j++) {
            if (t.charAt(0) == s.charAt(j)) count++;
            dp[0][j] = count;
        }

        //状态转移
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (t.charAt(i) == s.charAt(j)) {
                    dp[i][j] = dp[i - 1][j - 1] + dp[i][j - 1];
                } else {
                    dp[i][j] = dp[i][j - 1];
                }
            }
        }
        return dp[m - 1][n - 1];
    }
}
```



## 二、两个字符串的删除操作

[题目链接](https://leetcode.cn/problems/delete-operation-for-two-strings/)

**需求：**

给定两个单词`word1`和`word2`，请返回使得`word1`和`word2`相同所需要的最少操作数。操作只能是删除字符

```
输入: word1 = "sea", word2 = "eat"
输出: 2
解释: 第一步将 "sea" 变为 "ea" ，第二步将 "eat "变为 "ea"
```



**思路：**

`dp[i][j]`表示以word1[i]结尾的字符串，以word2[j]结尾的字符串，转换所使用的最少操作数

```java
class Solution {
    public int minDistance(String word1, String word2) {
        int m = word1.length();
        int n = word2.length();
        if (m == 0) return n;
        if (n == 0) return m;

        //dp初始化
        int[][] dp = new int[m][n];
        int tag = 0;
        for (int j = 0; j < n; j++) {
            if (word1.charAt(0) == word2.charAt(j)) tag = 2;
            dp[0][j] = j + 2 - tag;
        }

        tag = 0;
        for (int i = 0; i < m; i++) {
            if (word2.charAt(0) == word1.charAt(i)) tag = 2;
            dp[i][0] = i + 2 - tag;
        }

        //状态转移
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (word1.charAt(i) == word2.charAt(j)) {
                    dp[i][j] = dp[i - 1][j - 1];
                }
                else {
                    dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]);
                    dp[i][j]++;
                }
            }
        }
        return dp[m - 1][n - 1];
    }
}
```



## 三、编辑距离

[题目链接](https://leetcode.cn/problems/edit-distance/)

**需求：**

给定两个单词`word1`和`word2`，请返回将`word1`转换成`word2`所使用的最少操作数。操作可以是插入\删除\替换一个字符

```
输入：word1 = "horse", word2 = "ros"
输出：3
解释：
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')
```



**思路：**

`dp[i][j]`表示以word1[i]结尾的字符串，以word2[j]结尾的字符串，转换所使用的最少操作数

```java
class Solution {
    public int minDistance(String word1, String word2) {
        int m = word1.length();
        int n = word2.length();
        if (m == 0) return n;
        if (n == 0) return m;

        //dp初始化
        int[][] dp = new int[m][n];
        int tag = 0;
        for (int j = 0; j < n; j++) {
            if (word1.charAt(0) == word2.charAt(j)) tag = 1;
            dp[0][j] = j + 1 - tag;
        }

        tag = 0;
        for (int i = 0; i < m; i++) {
            if (word2.charAt(0) == word1.charAt(i)) tag = 1;
            dp[i][0] = i + 1 - tag;
        }

        //状态转移
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (word1.charAt(i) == word2.charAt(j)) {
                    dp[i][j] = dp[i - 1][j - 1];
                }
                else {
                    dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]);
                    dp[i][j] = Math.min(dp[i][j], dp[i - 1][j - 1]);
                    dp[i][j]++;
                }
            }
        }
        return dp[m - 1][n - 1];
    }
}
```

