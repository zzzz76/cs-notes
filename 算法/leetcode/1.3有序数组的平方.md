# 有序数组的平方

[题目链接](https://leetcode-cn.com/problems/squares-of-a-sorted-array/)



## 需求

给出一个非递减的整数数组，返回每个数字的平方组成的新数组

```
Input: nums = [-4,-1,0,3,10]
Output: [0,1,9,16,100]
```



## 思路

### 暴力排序

对每个数平方之后，进行排序

```java
class Solution {
  public int[] sortedSquares(int[] nums) {
    for (int i = 0; i < nums.length; i++) {
      nums[i] = nums[i] * nums[i];
    }
    Arrays.sort(nums);
    return nums;
  }
}
```



### 双指针

数组平方的最大值就在数组的两端，不是左边就是右边。从两端往中间不断靠拢，就可以获取当前最大值

```java
class Solution {
  public int[] sortedSquares(int[] nums) {
    int l = 0;
    int r = nums.length - 1;
    int[] res = new int[nums.length];
    int j = nums.length - 1;
    while (l <= r) {
      if (nums[l] * nums[l] > nums[r] * nums[r]) {
        res[j--] = nums[l] * nums[l++];
      } else {
        res[j--] = nums[r] * nums[r--];
      }
    }
    return res;
  }
}
```



反过来，从中间往两端不断外扩，就可以获取当前最小值

```java
class Solution {
  public int[] sortedSquares(int[] nums) {
    int m = 0;
    while (m < nums.length && nums[m] < 0) {
      m++;
    }
    
    int l = m - 1;
    int r = m;
    int[] res = new int[nums.length];
    int j = 0;
    while (l >= 0 && r < nums.length) {
      if (nums[l] * nums[l] < nums[r] * nums[r]) {
        res[k++] = nums[l] * nums[l--];
      } else {
        res[k++] = nums[r] * nums[r++];
      }
    }
    
    while (l >= 0) {
      res[k++] = nums[l] * nums[l--];
    }
    while (r < nums.length) {
      res[k++] = nums[r] * nums[r++];
    }
    return res;
  }
}
```

